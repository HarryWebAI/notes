# 面向对象基础

### 面向对象

- 面向对象是一种编程思想，与之对应的还有面向过程
- 面向对象强调【封装、继承、多态】，以洗衣服为例
- 面向过程类似于手洗，专注于洗衣服的过程：泡水，倒入洗衣液、搓、清、晾
- 面向对象类似于机洗：专注于找谁帮我干这件事，我们找洗衣机帮我们洗衣服：人只需要点击洗衣机装好的功能即可
- 上面的洗衣机就是一个对象，让洗衣机帮我们洗衣服就是调用对象的方法
- 这样编程的好处是：下次洗衣服，我们只需要把衣服塞进洗衣机，运行洗衣机已经写好的相关功能即可
- 而如果面向过程（手洗），我们还是需要从头泡水、倒入洗衣液、搓、清、晾

### 类和对象

- 类是洗衣机的草图
- 类的三要素:类名,属性,功能
- 定义一个类`class 类名:`
- 对象是根据草图画出来的实例
- 调用属性`类.属性`
- 调用方法`类.方法()`
- 在类中定义方法,都要求参数第一个是"self"
- 实例化一个对象`对象名 = 类名()`
- 上面的 self 此时指到对象自己,类型是 object
- 调用属性和方法:同上`对象.属性 or 方法()`
- 类属性可以理解为给即将新建的对象配置一个默认值,方便复用

### 构造函数

- `__init__(self,agrs1,args2,...)` 新建对象,即每次实例化一个类时,自动执行该函数
- 用于属性初始化或者赋值操作

### 析构函数

- `__del__(self,agrs1,args2,...)` 删除对象,即每次删除对象,释放内存时,自动执行该函数
- 实现删除对象的途径:第一种代码跑完,第二种`del 对象名`

### 封装

- 将复杂的信息,流程包起来,内部处理,让使用者通过简单的操作步骤,就能实现功能.
- 但是有些属性和方法,不希望被外部访问,这一过程就是封装
- 隐藏的 private:只允许类内部使用 `__属性名`和`__方法名()`
- 访问隐藏属性的方法 1:`_类名__属性名`可以访问隐藏属性,**不推荐**
- 访问隐藏属性的方法 2:在类中写一个函数,该函数读取该类的隐藏属性即可,**推荐**
- 访问隐藏方法同样
- 私有的 protected:`_属性名`和`_方法名()`
- 私有属性:一般用于防止与 Python 自带的关键字命名冲突而采用的命名方法
- 访问私有属性或方法:`对象名._属性名`或者`对象名._方法名`
- 公开的 public:没有下划线的

### 继承

- 子类默认继承父类所有的属性和方法
- 定义一个子类`class 子类名(要继承的父类):`
- 单继承:子类继承一个父类
- 多重继承,子类拥有父类以及父类的父类的属性,前提是父类继承过"爷类"
- 方法的重写覆盖:在子类中定义与父类相同名称的方法
- 逻辑就是:调用一个方法,子类先找自己有没有这个方法,如果没有,就找父类的
- 在子类中重写方法,但又需要调用父类的方法:`super().方法名()`
- `super()`是一个特殊类的实例化对象,在文中就是一个临时的,当前子类的父类的实例化对象
- 多继承:子类继承多个父类,并且具有所有父类的属性和方法
- 多个父类具有同名方法时,子类先继承左边的(括号内就近原则),但是实际开发应该避免这种情况
- 类的方法,属性搜索顺序可以同代码`类名.__mro__`查看
- 多继承的弊端：容易引发依赖冲突
- 了解:python3 中,所有的类都继承一个"始祖类",叫做 object.

### 多态

- 同一行为具有不同的表现形式
- 多态的前提：继承、重写
- 多态的特点
  - 不关注对象的类型，只关注对象的行为，也就是对象的实例方法是否同名
  - 多态的好处是可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强
  - 不同子类对象，调用相同父类方法，会产生不同执行结果

### 静态方法

- 与类无关，可以转换为函数使用

```python
@staticmethod
def functionName(args1,args2,...): #不用self但可以带其他参数
    pass
```

- 取消不必要的参数传递，比如不要 self，有利于减少内存占用

### 类方法

- 类方法：可以访问类属性，调用其他的类方法，一般配合私有属性和私有方法使用。

```python
@classmethod
def functionName(cls,args1,agrs2,...):  #第一参数必须是cls。代表类自己
    pass
```

- 当方法中需要使用类对象（比如访问类的私有属性时），就可以使用类方法

# 单例模式

- 先讲以下创建一个对象的过程：
  - 执行 Python 自己写好的 object 基类的`__new()__`方法，该方法返回值是一个 object 对象，赋值给 self
  - 如果有写`__init__(self)`：那这里的 self 就是`__new()__`里返回的那个对象
  - 如果要重写`__new(cls,*args,**kwargs)__`：一定要`return super().__new__(cls)`
- 单例模式，其实就是配置一个特殊的类，这个类只存在一个对象，后续哪怕创建再多实例，都是那一个对象，指向一个内存地址
- 主要用于节省内存空间，但多线程访问容易引发线程安全问题
- 实现单例模式

```python
class Test:
    # 定义内存地址
    obj = None
    # 重写__new()__实现
    def __new__(cls, *args, **kwargs):
        if cls.obj == None:
            # 配置地址
            obj = super().__new__()
        return cls.obj
```

- 导入模块，模块就是天然的单例模式
- 单例模式的应用场景：回收站、音乐播放器...

# 魔法方法

- 其实前面已经用了三个魔法方法了
- 通常`__xxx__`就是魔法方法、魔法属性

```python
__new__() #新建类时立刻执行的方法
__init__() #类创建后初始化执行的函数
__del__() #类销毁时自动执行的函数
__doc__ #描述信息属性，也就是类或者函数下面的多行注释
__module__() #返回当前操作对象所在的模块
__class__() #返回当前操作对象所属的类
__str__() #如果类中定义了该方法，那么打印该对象时，默认输出该方法的返回值，且该值必须为一个字符串
__call__() #使一个实例对象成为一个可调用对象 callable()判断变量是否是可调用对象
```
